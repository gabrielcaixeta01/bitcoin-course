import os, hashlib
from ecdsa import SigningKey, SECP256k1, util

#Questão 1 
'''
def pubkey_compressed_from_vk(vk):
    xy = vk.to_string()
    x = xy[:32]
    y = xy[32:]

    prefix = b'\x02' if (y[-1] % 2 == 0) else b'\x03'
    return prefix + x


sk = SigningKey.generate(curve=SECP256k1)
vk = sk.get_verifying_key()

message = b"Hello Bitcoin!"

pb_compressed = pubkey_compressed_from_vk(vk)
pub_hex = pb_compressed.hex()

sig_rs = sk.sign(message, hashfunc=hashlib.sha256, sigencode=util.sigencode_string)
sig_hex = sig_rs.hex()

print("Public key (compressed, 66 hex):", pub_hex)
print("Signature (r||s, 128 hex):     ", sig_hex)

'''

#Questão 2
'''
signature_hex = "133c76589b4cce6898e63a366e40d43a6471db814f5a354d52c4abcd067942780cc9b3d891c9a4eb8bcce6edc20f31937005595a7f7ea6a4bf20c3f6367f5155"
k_hex = "718768e4b0ec256839ddcba80b7902a361d525f4be8c4904c275edd35625afb5"

message_orig = b"Satoshi Nakamoto"
target_msg = b"I broke ECDSA!"

n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

r = int(signature_hex[:64], 16)
s = int(signature_hex[64:], 16)
k = int(k_hex, 16)
z = int.from_bytes(hashlib.sha256(message_orig).digest(), "big")

r_inv = pow(r, -1, n)
d = ((s * k - z) * r_inv) % n
d = d.to_bytes(32, "big")

sk = SigningKey.from_string(d, curve=SECP256k1)
sig_rs = sk.sign(target_msg, hashfunc=hashlib.sha256, sigencode=util.sigencode_string)
sig_hex = sig_rs.hex()

print(sig_hex)

'''

#Questão 3
'''
sig1_hex = "4264b8b1ef4c77bf259a8d144689a0e6ea1aa6daf3761eb28b8b8669cf72f73907d78eea283d3841716efdd6eae4f559bc670f2674d0e4ffb66774c4796f71e6"
sig2_hex = "4264b8b1ef4c77bf259a8d144689a0e6ea1aa6daf3761eb28b8b8669cf72f73905a3eb1483b5498908be8c05c40da3e5a4d5d5cdfb1dc1f8adaca890a67605b0"

m1 = b"Edil Medeiros"
m2 = b"Neha Narula"
target_msg = b"I broke ECDSA again!"
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

r1 = int(sig1_hex[:64], 16)
s1 = int(sig1_hex[64:], 16)
r2 = int(sig2_hex[:64], 16)
s2 = int(sig2_hex[64:], 16)

assert r1 == r2, "Nao usaram o mesmo k"
r = r1

z1 = int.from_bytes(hashlib.sha256(m1).digest(), "big")
z2 = int.from_bytes(hashlib.sha256(m2).digest(), "big")

numerador = (z1 - z2) % n
denominador = (s1 - s2) % n
k = (numerador * pow(denominador, -1, n)) % n

d = ((s1 * k - z1) * pow(r, -1, n)) % n
d = d.to_bytes(32, "big")

sk = SigningKey.from_string(d, curve=SECP256k1)
sig_rs = sk.sign(target_msg, hashfunc=hashlib.sha256, sigencode=util.sigencode_string)
sig_hex = sig_rs.hex()

print("signature (r||s, hex):", sig_hex)
'''

#Questão 4
'''
m = b"transfer 100 BTC"
signature = "f474d12468415184847778e455189eb0a07df7696d69777008f59fe9ebe497727739e65b40f2a1587b47e953d6fdec9934e82c45c00fe41d446347f35b74708f"
public_key = "020e7d4f8640ec6f3382a1dd61b4b292f815864dc7b6c12ba2744597aa3504d674"

r = int(signature[:64], 16)
s = int(signature[64:], 16)
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

new_s = n - s
new_sig = (r.to_bytes(32, "big") + new_s.to_bytes(32, "big")).hex()
print(new_sig)
'''

#Questão 5

from ecdsa.curves import SECP256k1

INP = "data/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16.dat"
OUT = "solutions/exercise05.txt"
N = SECP256k1.order

raw = open(INP, "rb").read()

s = raw.decode().strip()
tx = bytes.fromhex(s) if len(s) % 2 == 0 and all(c in "0123456789abcdefABCDEF" for c in s) else raw

i = 0
while i < len(tx) and tx[i] != 0x30:
    i += 1

ln = tx[i+1]
p = i + 2

assert tx[p] == 0x02; p += 1
lr = tx[p]; p += 1
r_bytes = tx[p:p+lr]; p += lr

assert tx[p] == 0x02; p += 1
ls = tx[p]; p += 1
s_bytes = tx[p:p+ls]

r32 = int.from_bytes(r_bytes, "big").to_bytes(32, "big")
s  = int.from_bytes(s_bytes, "big")
sprime32 = ((N - s) % N).to_bytes(32, "big")

buf = bytearray(113)               
buf[47:79] = r32                   
buf[79:81] = b"\x00\x00"   
buf[81:113] = sprime32

with open(OUT, "w") as f:
    f.write(buf.hex() + "\n")

print(buf.hex())